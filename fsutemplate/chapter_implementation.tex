\chapter{Implementation}

\section{The RTPS Library}

In this section we discuss the various classes which make up the Real-Time
Particle System framework. Filenames will be denoted as such \verb|rtpslib/RTPS.h|
and refer to the directory structure of the code. \toi{link to code here? or
reference?}

\subsection{RTPS}

The entry point into the framework is the \verb|rtpslib/RTPS.h| header file. This file defines
the RTPS class which a user of the library will instanciate in order to run a
particle based simulation. The Application Programmers Interface (API) is
relatively simple, giving the user an object which only exposes two methods, a
\verb|update| function and an \verb|render| function. These two functions abstract
internal logic for updating the simulation and displaying of the particles. The
constructor to the class accepts either no arguments or an \verb|RTPSettings| object.
This object contains many settings including the type of simulation to
instanciate, rendering options as well as simulation parameters. 

The typical use case (with default settings) is envisioned as follows
\begin{cppcode}{0}
#include "RTPS.h"
using namespace rtps;
//... initialization phase ...
RTPSettings settings();
RTPS ps(settings);

//... run loop ...
while(true)
{
    //... event handling and game logic
    ps.update()
    //... rendering phase
    ps.render()
}

\end{cppcode}

The class is implemented in \verb|rtpslib/RTPS.cpp|.

\subsection{RTPSettings}

Options and parameters for the system are stored in a private STL Map object
defined in \verb|rtpslib/RTPSettings.h| and accessed through public getter and
setter methods. The available settings are not determined by this class, but by
the implementation of each system. This is desirable since different systems
will offer different combinations of settings and rather than creating,
implementing and innevitably changing new constructors, the proper combination
of settings can be set with calls to the setter functions. This is especially
convenient when developing for a user interface such as in Blender where the
configuration of settings is not known until runtime.  
An example of specifying the available settings for SPH can be found in
\verb|rtpslib/system/SPHSettings.h|.
\toi{put a couple examples of getting and setting some settings here}


\subsection{System}

Interaction with the simulation is provided through the \verb|system| object which
will have various methods depending on what type of simulation was set in the
settings. The most important methods are those which allow the user to add
particles to a system, namely \verb|addBox|, \verb|addBall| and \verb|addHose|. For the fluid
simulation there is also the \verb|loadTriangles| method which allows the user to
pass in triangles for the fluid particles to collide with.

These methods are declared in the System.h header file which defines an
Abstract Class \verb|System|. The methods are implemented in the specific system
classes such as \verb|SPH| and \verb|Simple|.

\subsection{Common Structures}

Utilized throughout the code is the \verb|float4| struct. \verb|float4| structs are used
to represent coordinate positions of the particles, as well as many of the
properties associated with the particles such as density, velocity and force.
The functionality of the \verb|float4| class match the OpenCL \verb|float4| type as close
as possible. We have overloaded several operators for constructing and doing
arithmetic as well as provided a print function. This functionality allows the
developer to quickly construct data for interacting with the system. Being able
to reimplement an OpenCL routine on the CPU is also convenient for debugging
logic since it makes printing output much simpler. 
There is also the \verb|int4| struct which is similarly a vector of four integers
for more convenient communication with OpenCL.
the declarations and definitions for these structures and related functions can
be found in \verb|rtps/structs.h| and \verb|rtps/structs.cpp|


\subsection{Domain}

The \verb|Domain| class calculates and stores the parameters for a regular grid
on the interior of a cube. The cube serves as a bounding domain for the
particles in a simulation, wheras the grid is used to accelerate the neighbor
search for particles. It is important to note that the grid is not stored as a
set of nodes or cells, only the minimum and maximum of the cube along with the
size and number of cells in each dimension.

The \verb|Domain| class is found in \verb|rtps/domain/Domain.h| and
\verb|rtps/domain/Domain.cpp| alongside \verb|rtps/domain/IV.h| and
\verb|rtps/domain/IV.cpp| which define several helper functions for inserting
particles at regularly spaced intervals based on grid parameters.



\section{SPH Routines}

The update function for the Smoothed Particle Hydrodynamic simulation can be
broken down into three distinct parts. The first is the Nearest Neighbor search
which computes the SPH forces for each particle in an efficient manner, the
second is the handling of collisions with the domain boundary as well as with
arbitrary triangular meshes, and the third is advecting the particles by
integrating their SPH forces over time. 

\subsection{Nearest Neighbor Search}
* grid/hash technique for nearest neighbor sort



\subsubsection{Particle Insertion}
\toi{does this go here? seems like a good place}
\subsubsection{Particle Deletion}

\subsection{SPH Calculations}

\subsubsection{Density}

\subsubsection{Force}


\subsection{Collision Detection}


\subsection{Integration}



\section{OpenCL}

The framework provides several classes to abstract access to OpenCL routines.
The underlying OpenCL functionality is provided by the Khronos C++ header files
as discussed in Chapter 3 (GPU Computing).\toi{need to be able to link to a chapter}
The purpose of these classes is convenience for the developer, hiding tedious
and repetitive behavior and providing sensible default behavior. The classes
are not intended to be a general replacement for the official OpenCL interface,
and focus primarily on the functionality required in this project.



\subsection{CLL}
* class which instanciates opencl

\subsection{Kernel}


\subsection{Buffer}


\subsection{Shared memory optimization}
* shared memory optimization - collisions and hash datastructure 


\subsection{Debugging Routines}

It is often desirable to output the values of a variable while debugging code,
however this is currently not simple with OpenCL. We have implemented a pattern
using a set of macros in the kernel source code as well as two dedicated arrays
with corresponding GPU buffers. When debugging a kernel the programmer will
pass the two buffers as the final arguments, with the first buffer being an
array of \verb|float| and the second buffer being an array of \verb|int4|. 
Inside the kernel the user will have the folowing macros defined (we include
these in our cl\_macros.h header)
\begin{cppcode}{0}
#define DEBUG_ARGS  , __global float4* clf, __global int4* cli
#define DEBUG_ARGV  , clf, cli
\end{cppcode}

Here \verb|DEBUG_ARGS| is added to the kernel's list of parameters as well as
to the argument list of any functions which we wish to debug in.
\verb|DEBUG_ARGV| is used when calling functions with the debug arguments. This
way one can easily extend or change the debugging arrays without the tedious
task of adding and subtracting arguments to kernel and function definitions,
and when done debuging one can simply redefine the macros to be empty.

Once the programmer has these arrays available inside of the kernel and updates
their contents in OpenCL, the next step is bringing these arrays back to the
CPU for printing and other analysis. The \verb|Buffer| class provides a
\verb|copyToHost| routine which makes this straight forward. Simply initialize
an empty vector of the same type as the array, with size equal to the
number of elements to be copied from the GPU. Then pass this vector to the routine:
\begin{cppcode}{0}
//where mybuffer was instantiated like Buffer<float4>(...)
std::vector<float4> tmp(100);
mybuffer.copyToHost(tmp);
//or to copy 100 elements starting at the 500th element (offset of 500)
mybuffer.copyToHost(tmp, 500);
\end{cppcode}

The vector \verb|tmp| will then be populated with the data from the GPU and can
be printed and manipulated using all of the familiar CPU functions available to
the programmer. 

\section{CMake}
\toi{explain cmake structure and main features used}
cross-platfrom build system used in many large open source projects.


integrate with blender's build system as a subdirectory


\section{OpenGL}
* Render class


* vertex buffer objects


* Point sprites (billboards)




\section{Blender Source Modification}

In order to use the RTPS library inside the Blender Game Engine the source code
for Blender must be modified. The manner in which RTPS is exposed to Blender is
through a construct known as a Modifier. The purpose of a Blender Modifier is
to enable custom functionality on a Blender Object, usually resulting in a
modification of the Object's data. In the Blender Game Engine all modifiers on an Object are
$Applied$ at the start of a game and are $Updated$ every frame. The definition
of $Apply$ and $Update$ depend on the Modifier, and in the case of RTPS it is
desirable to instanciate the particle system when the Modifier is $Applied$ and
to calculate the next timestep when $Updated$.


Blender Modifiers are specified using the Blender DNA system, using a C
structure to store associated data. A Modifier's data can be exposed to the Blender User Interface
through Blender's Data API and Python scripting interface. The Blender Data API
is a way to programmatically access data structures used by Blender without
needing to know the details of how they are stored.\cite{b3dDataAPI} The User
Interface for Blender is controlled with Python, and the Python/RNA API gives
access to the Data API so that the values and functionality of a data structure
can be manipulated in the User Interface.\footnote{More information on
Blender's internal architecture is available at
\url{http://www.blender.org/development/architecture/}}


\subsection{User Interface}
%screenshot
For this project the $RTPS Modifier$ was created.\cite{enjaCustomModifier} The
data stored in the modifier are the configurations and run-time options for the
RTPS library.  These options are exposed to the game designer in a panel and
displayed according to a Python script which calls the RNA API. The RNA code
specifies aspects of the user interface such as the minimum and maximum values
allowed for an input, or the options available in a drop-down menu. The
appearance of the user interface elements is automatically created using the
defaults provided by Blender, which are suitable for the current configuration.


\subsection{Apply}
The values from the User Interface are passed to the RTPS library when the
Modifier is Applied at the start of the game. The control flow is as follows,
the Game Engine iterates through all of the objects in the scene and if the
object has a Modifier the Modifier's apply routine is called. This logic is
extended to check explicitly for the $RTPS Modifier$, and if present initialize
an RTPS instance.


The initialization involves passing in the values of the Modifier struct to the
RTPS settings instance as well as constructing a Domain object from the Axis
Aligned bounding box of the object which the Modifier is Applied to.

\subsection{Update}

The Update routine works similarly to the Apply routine with respect to control
flow. The Update routine is called for every frame of the game, rather than
only once at the start. In addtion to calling the update routine of the RTPS
instance, this is where most of the interaction between the Game Engine and the
library takes place.

\subsubsection{Collision}
Objects to be used for collision detection are dealt with in the update routine
by checking for a specific game property. If the boolean value of the
$collider$ property is true the faces of the object will be collected in a
vector and passed to the RTPS instance as Triangle objects. This does assume
that the mesh of the object is composed purely of Triangles. 

\subsubsection{Emission}
Objects which emit particles are also handled in the Update routine. The
objects are detected and handled depending on which Game Properties are
present. Currently there are two types of emitters, Blob and Hose. A Blob
emitter will fill a user specified box with a user specified amount of
particles. The spacing of the particles is determined by the relation of the
particle radius to the domain size. This means that a user may attempt to fill
the volume with more particles than will fit, in which case only the number of
particles which fit will be emitted. If the user requests to emit more
particles than the maximum allowed, no particles will be emitted.
The Blob emitter is determined in blender by the presence of the $num$
property. Every frame, if the $num$ property is greater than zero, $num$
particles are emitted from the volume given by the Object's Axis Aligned
Bounding Box and the $num$ is set to zero. In this way it is possible to
provide interactive emissions of particles by using the Logic Bricks to change
the $num$ property during game play.
%screenshot

The Hose emitter will spray a stream of particles in the direction and speed of
a user specified velocity vector. The radius of the nozzle is specified as a
multiple of the particle spacing. The Hose has a set number of particles it
will emit, and each frame a disc of particles is emitted at a rate proportional
to the time step and the velocity. The number of particles emitted each frame
is subtracted from the total number available to the Hose until there are no
more particles left, at which point the Hose will stop spraying. The positions
of the particles emitted in the disc are also slightly randomized (by one
particle spacing) along the velocity vector as well as along the plane of the
disc, giving a more natural depiction of spray.

A Hose is specified by the presence of the boolean $hose$ game property. The
value of the $hose$ property determines whether or not the Hose is activated.
The rest of the functionality for the Hose is controlled by the $num$, $radius$
and $speed$ properties. The $num$ property specifies the total amount of
particles available to the hose, the $speed$ property gives the initial
velocity of the particles emitted from the hose while the $radius$ determines
how wide the Hose is. The direction of the Hose is determined by the
orientation of the Y axis of the Hose Object.

\subsection{Orientation}
In Blender Objects are positioned in a Global coordinate system, with data
(such as vertices) specified in a Local coordinate system relative to the
Object's center. In the RTPS library particles are positioned in a coordinate
system relative to the Domain. In order for Blender and RTPS objects to
interact it is essential that objects can be represented in one of the two
coordinate systems. This is accomplished by using Blender's Global coordinate
system when passing information from Blender to RTPS. To use the Global
coordinate system for an Object, one multiplies a given local coordinate by the
Global Rotation and Transformation matrices maintained by the Game Engine for
the Object. This is done for the Domain, as well as Collider and Emitter
Objects, making all spatial coordinates in RTPS the Blender Global coordinates.

%screenshot
\subsection{Render}
Rendering of the RTPS particles in the Blender Game Engine is accomplished by
taking control of the way the Object with the $RTPS Modifier$ is displayed. The
Game Engine manages a list of all Objects to be rendered and calls various
OpenGL rasterization routines depending on properties and materials of the
Object. In order to render the RTPS particles the $render$ method of the RTPS
instance must be called. In the Game Engine rasterization code a conditional
statement was added to check for the presence of the $RTPS Modifier$, and if
present the normal rendering is bypassed and the $render$ routine of the RTPS
instance is called instead.

\subsection{Files}
For a complete list of Blender source files modified by the project please refer to Appendix X\toi{link to an appendiex with MODIFIED FILES}

